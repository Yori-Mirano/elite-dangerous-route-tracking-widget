<!DOCTYPE html>
<html>
  <head>
    <title>Elite Dangerous - Route Tracking Widget</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="black">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <script src="/socket.io/socket.io.js"></script>

    <style>
      :root {
        --gui-size-factor   : 1;
        --color-theme       : #ff8b00;
        --color-on          : white;
        --color-off         : var(--color-on);
        --color-background  : #0008;
        --color-off-alpha   : .5;

        scrollbar-width: none;

        font-size: calc(var(--gui-size-factor) * 62.5%); /* 1rem = 10px */
      }

      ::-webkit-scrollbar             { display: none; }

      :root, body { height: 100%; }

      body {
        background-color: black;
        margin: 0;
        display: flex;
        overflow: hidden;
        font-family: Verdana, sans-serif;
        text-shadow: 0 0 .5rem var(--color-background);
      }
  
      /**
       * Info
       */
      .info {
        flex-shrink: 0;
        color: white;
        padding: 0 1rem;
        font-size: 1.2rem;
        display: flex;
        flex-direction: column;
        justify-content: center;
        background-image: radial-gradient(var(--color-background), transparent 66%, transparent);
      }

      .info * :first-child { color: var(--color-on); }
      .info * :last-child { color: var(--color-theme); }


      /**
       * Route
       */
      .route-container {
        flex-grow: 1;
        display: flex;
        overflow-y: hidden;
        background-image: radial-gradient(var(--color-background), transparent 66%, transparent);
        -webkit-mask-image: linear-gradient(to right, transparent, black 6rem, black calc(100% - 6rem), transparent);
      }

      ul {
        display: flex;
        margin: 0 auto;
        padding: 0 10rem;
        list-style-type: none;
      }
  
      li {
        display: flex;
        align-items: center;
        position: relative;
      }

      li                      { --color: var(--color-theme); }
      li > span               { opacity: var(--color-off-alpha); --color: var(--color-off); }

      li.current              { --color: var(--color-on); }
      li.current::before      { --color: var(--color-theme); }
      li.current ~ li::before,
      li.current ~ li::after  { opacity: var(--color-off-alpha); --color: var(--color-off); }

      li.jumping::after,
      li.jumping::before      { --color: var(--color-on); }
      li.jumping::after,
      li.jumping ~ li::before,
      li.jumping ~ li::after  { opacity: var(--color-off-alpha); --color: var(--color-off); }
  
      li::after {
        content: "";
        box-sizing: border-box;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        color: var(--color);
        border: .2rem solid;
        transition-property: color, background-color, opacity;
        transition-duration: .5s;
      }

      li.scoopable::after {
        border-width: 0;
        background-color: var(--color);
      }

      li.supercharge::after,
      li.white-dwarf::after {
        content: "Â¦";
        font-size: 2.2rem;
        padding-bottom: .5rem;
        justify-content: center;
        align-items: center;
        display: flex;
        border-top: none;
        border-bottom: none;
        width: .8rem;
        height: .8rem;
        margin: .1rem;
        transform: rotate(45deg);
      }

      li.white-dwarf::after {
        width: 1.4rem;
        height: 1.4rem;
        margin: 0;
      }
      
      li.black-hole::after {
        border: none;
        width: 1.6rem;
        height: 1.6rem;
        background-image: radial-gradient(transparent 0%, var(--color) 32%, transparent 45%, transparent 50%, var(--color) 60%);
      }
  
      li + li::before {
        content: "";
        display: block;
        width: 3.5rem;
        height: .2rem;
        margin: 0 .2rem;
        background-color: var(--color);
        transition: all .5s;
      }
  
      li > span {
        position: absolute;
        right: .5rem;
        transform: translate(50%, 2rem);
        width: 12ch;
        font-size: 1.2rem;
        text-align: center;
        line-height: 1;
        color: var(--color);
        transition: opacity .5s, color .5s;
      }

      li.current > span {
        color: var(--color-on);
        opacity: 1;
      }
  
      li:nth-child(odd) > span {
        transform: translate(50%, -2rem);
      }

      @keyframes pulse {
        from { background-position: 0; }
        to   { background-position: 100%; }
      }

      li.jumping::before {
        animation: pulse infinite 3s linear;
        background-image: linear-gradient(to right, transparent, white, transparent);
        background-color: transparent;
        background-size: 20%;
      }

      li.jumping > span {
        color: var(--color-on);
        opacity: 1;
      }

      li.compact:not(.current):not(.jumping):not(:first-child) + li.compact:not(.current):not(.jumping):not(:last-child)::before {
        width: 0;
      }

      li.compact:not(.current):not(.jumping):not(:first-child):not(:last-child) > span {
        opacity: 0;
      }
    </style>
  </head>
  
  <body>
    <input type="color" oninput="document.documentElement.style.setProperty('--color-theme', this.value)"/>

    <script>
      /**
       * Helpers
       */
      function createElement(parentEl = document.body, tagName = 'div') {
        const el = document.createElement(tagName);
        parentEl.appendChild(el);
        return el;
      }

      
      function getDistance(positionA, positionB) {
        return Math.sqrt(
          Math.pow(positionA.x - positionB.x, 2)
          + Math.pow(positionA.y - positionB.y, 2)
          + Math.pow(positionA.z - positionB.z, 2)
        );
      }

      function centerView() {
        if (lastSystem && systemList[lastSystem]) {
          const currentSystemElementPosition = systemList[lastSystem].system.getDomElementPosition();
          const newScrollPosition = currentSystemElementPosition - (routeContainerEl.offsetWidth / 2);
          routeContainerEl.scrollTo({left: newScrollPosition, behavior: "smooth"});
        }
      }

      /**
       * Infos
       */
      class Info {
        el;
        remainingJumps;
        lastJumpDatetimeInMilliseconds;
        _remainingMinutes;
        _position;
        _totalJumpDurationInSeconds = 0;
        _totalJumpDistance = 0;
        _jumpTotalForDurationStat = 0;
        _jumpTotalForDistanceStat = 0;
        

        constructor() {
          this.el = createElement();
          this.el.classList.add('info');
          this.updateView();
        }

        setRemainingJump(remainingJump) {
          this.remainingJumps = remainingJump;
          this.updateView();
        }

        jump(position) {
          this._updateMillisecondsPerJumpStat();
          this._updateLightYearPerJumpStat(position);
          this.updateView();
        }

        setPosition(position) {
          this._position = position;
          this.updateView();
        }

        setArrivalPosition(position) {
          this._arrivalPosition = position;
          this.updateView();
        }

        getArrivalDistance() {
          let distance;

          if (this._position && this._arrivalPosition) {
            distance = getDistance(this._position, this._arrivalPosition);
          }
          
          return Math.round(distance);
        }

        endOfRoute() {
          this.lastJumpDatetimeInMilliseconds = null;
          this._position = null;
        }

        _updateMillisecondsPerJumpStat() { 
          const now = Date.now();

          if (this.lastJumpDatetimeInMilliseconds) {
            const jumpDurationInMilliseconds = now - this.lastJumpDatetimeInMilliseconds;
            this._totalJumpDurationInSeconds += jumpDurationInMilliseconds / 1000;
            this._jumpTotalForDurationStat++;
          }

          this.lastJumpDatetimeInMilliseconds = now;
        }

        _updateLightYearPerJumpStat(position) {
          if (this._position) {
            const jumpDistance = getDistance(this._position, position);
            this._totalJumpDistance += jumpDistance;
            this._jumpTotalForDistanceStat++;
          }

          this.setPosition(position);
        }

        getLightYearPerJump() {
          return (this._totalJumpDistance / this._jumpTotalForDistanceStat)
              || (this.getArrivalDistance() / this.remainingJumps);
        }

        getSecondsPerJump() {
          return Math.round(this._totalJumpDurationInSeconds / this._jumpTotalForDurationStat)
              || 60;
        }

        getRemainingTime() {
          return Math.round(this.getSecondsPerJump() * this.remainingJumps / 60)
              || 0;
        }

        getJumpsPerHour() {
          return Math.round(60 * 60 / this.getSecondsPerJump());
        }

        updateView() {
          this.el.innerHTML = `
            <div>
              <div style="display: flex; align-items: flex-end; justify-content: space-between; border-bottom: .1rem solid var(--color-off); padding-bottom: .4rem; margin-bottom: .5rem;">
                <div style="font-size: 1.7rem; font-weight: bold; line-height: 1; text-align: right;"><span>${this.getRemainingTime()}</span><div style="font-size: 1.1rem;"> min</div></div>
                <div style="margin-left: .8rem;">
                  <div><span>${this.getArrivalDistance()}</span><span> ly</span></div>
                  <div><span>${this.remainingJumps}</span><span> jmp</span></div>
                </div>
              </div>

              <div style="display: flex; justify-content: space-between;">
                <div>
                  <div><span>${Math.round(this.getLightYearPerJump() * this.getJumpsPerHour())}</span><span> ly/h</span></div>
                  <div><span>${Math.round(this.getLightYearPerJump())}</span><span> ly/jmp</span></div>
                </div>
                <div style="margin-left: 1rem; text-align: right;">
                  <div><span>${this.getJumpsPerHour()}</span><span> jmp/h</span></div>
                  <div><span>${this.getSecondsPerJump()}</span><span> s/jmp</span></div>
                </div>
              </div>
            </div>`;
        }
      }

      /**
       * System
       */
      const SCOOPABLE_STAR_CLASSES = [ 'O', 'B', 'A', 'F', 'G', 'K', 'M' ];

      class System {
        el;
        labelEl;
        starClass;
        position;

        constructor(parentEl, name, starClass, position) {
          this.el = createElement(parentEl, 'li');
          this.labelEl = createElement(this.el, 'span');
          this.labelEl.innerHTML = name;
          this.starClass = starClass;
          this.position = position;

          if (name.match(/\d/) !== null) {
            this.el.classList.add('compact');
          }

          if (this.isScoopable()) {
            this.el.classList.add('scoopable');
          }

          if (this.isSupercharge()) {
            this.el.classList.add('supercharge');
          }

          if (this.isWhiteDwarf()) {
            this.el.classList.add('white-dwarf');
          }

          if (this.isBlackHole()) {
            this.el.classList.add('black-hole');
          }
        }

        isScoopable() {
          return SCOOPABLE_STAR_CLASSES.includes(this.starClass);
        }

        isSupercharge() {
          return this.starClass.match(/^(N|D.*)$/) !== null;
        }

        isWhiteDwarf() {
          return this.starClass.match(/^D/) !== null;
        }

        isBlackHole() {
          return this.starClass === 'H';
        }

        getPointSize() {
          return parseInt(window.getComputedStyle(this.el,'::after').width, 10);
        }

        getDomElementPosition() {
          return this.el.offsetLeft + this.el.offsetWidth - (this.getPointSize() / 2);
        }
      }

      /**
       * Init
       */
      let routeContainerEl = createElement();
      let routeEl = createElement(routeContainerEl, 'ul');
      let systemList = {};
      let lastSystem;
      const info = new Info();

      routeContainerEl.classList.add('route-container');

      window.addEventListener('resize', () => centerView() );

      /**
       * Socket.io client
       */
      var socket = io();

      socket.on('config', config => {
        document.documentElement.style.setProperty('--gui-size-factor', config.guiSizeFactor);
        document.documentElement.style.setProperty('--color-theme', config.themeColor);
        document.documentElement.style.setProperty('--color-background', config.backgroundColor);
        document.documentElement.style.setProperty('--color-off', config.fullColor ? 'var(--color-theme)' : 'var(--color-on)');
      });
    
      socket.on('route', route => {
        console.log('route:', route);

        routeEl.innerHTML = '';
        systemList = {};

        route.forEach((step, index) => {
          const system = new System(
            routeEl,
            step.StarSystem,
            step.StarClass,
            {
              x: step.StarPos[0],
              y: step.StarPos[1],
              z: step.StarPos[2]
            });

          systemList[step.StarSystem] = {
            remainingJump: route.length -1 - index,
            system: system
          };

          if (systemList[step.StarSystem].remainingJump === 0) {
            info.setArrivalPosition(systemList[step.StarSystem].system.position);
          }

          if (lastSystem == step.StarSystem) {
            system.el.classList.add('current');
            setTimeout(() => centerView());
            info.setPosition(systemList[step.StarSystem].system.position);
            info.setRemainingJump(systemList[lastSystem].remainingJump);
          }
        });
      });
    
      socket.on('system', systemName => {
        console.log('system:', systemName);

        if (systemName && systemList[systemName]) {
          const system = systemList[systemName].system;

          system.el.classList.remove('jumping');
          system.el.classList.add('current');
          setTimeout(() => centerView());
        }

        info.setPosition(systemList[systemName].system.position);
        info.setRemainingJump(systemList[systemName].remainingJump);

        lastSystem = systemName;
      });
      
      socket.on('jumping', systemName => {
        console.log('jumping:', systemName);
        
        if (lastSystem && systemList[lastSystem]) {
          systemList[lastSystem].system.el.classList.remove('current')
        }

        if (systemName && systemList[systemName]) {
          systemList[systemName].system.el.classList.add('jumping');
          lastSystem = systemName; 
          setTimeout(() => centerView());
        }

        info.jump(systemList[systemName].system.position);
        info.setRemainingJump(systemList[systemName].remainingJump);

        if (systemList[systemName].remainingJump === 0) {
          info.endOfRoute();
        }
      });
    </script>
  </body>
</html>